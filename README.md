# Lab01-CriptografiaUDP
Este repositorio fue hecho para compartir el trabajo hecho por Alejandro Saldías para el laboratorio 01 de Criptografía de la UDP.

A continuacion se hace una breve explicacion del funcionamiento de los codigos del repositorio:

- Cesar_translate.py: El primer codigo que tiene la funcionalidad de encodificar una frase o oracion o texto en si con el algoritmo cesar. Esta pensado para recibir dos campos, uno siendo el texto que se quiere encodear con Cesar y el otro campo siendo un numero que indicara el desplazamiento con Cesar. En caso de no insertar los parametros al ejecutarlo el programa se tomara una instancia para solicitar al usuario el ingreso de un texto a cifrar y luego un numero para hacer el desplazamiento en Cesar. En cuanto a especificaciones este programa esta pensado para el abecedario en español y considera tanto mayusculas como minusculas asi como tambien toma en cuenta los espacios, este programa no considera caracteres especiales o tildes y en caso de detectar un caracter que no pertenezca a lo que esta pensado en la logica data un aviso de error y pedira la reinsercion de la palabra a cifrar. Finalmente y para hacer una conexion sencilla con el siguiente codigo este genera un archivo de texto(mensaje_cifrado.txt) donde se guarda el mensaje cifrado para su posterior lectura por el siguiente codigo.

- Cesar_sender.py: El segundo codigo tiene la funcionalidad de mandar el mensaje cifrado por paquetes ICMP(echo ping requests) a la direccion de google(8.8.8.8) de tal forma que no se trigeree ningun tipo de alerta por mandar informacion misteriosa, para esto se lee el archivo previamente creado por el anterior codigo(mensaje_cifrado.txt) y se va mandando paquetes por separado para cada caracter en el mensaje y para evitar trigerear las alertas en vez de deposital la letra del mensaje en el payload se mando en el identificador pasando el caracter a un hexadecimal para que pase desapercibido. Fuera de eso el codigo se da un espacio de 0.5s entre cada paquete para evitar que se trigerre una alerta por mandar muchos requests muy rapido.

- Cesar_descifrator.py: El tercer codigo y el mas independiente de estos por asi decirlo, este se encarga de captar los paquetes requests que se mandan con Cesar_sender.py y revisa las letras que estan almacenadas en el identificador pasandolas de hexadecimal devuelta a su caracter correspondiente para luego tratar de examinar todas las posibilidades de cifrado con Cesar disponibles para el mensaje y hacer una aseveracion informada en base a las palabras generadas para poder decir cual era el mensaje original, para este codigo el mensaje final que deberia ser el original sera marcado con verde. Consideraciones son que este codigo esta pensado para funcionar por un total de 10 segundos y el timer se ira reiniciando cada vez que este capte un paquete, en el caso de que no detecte nada por 10 segundos consecutivos dara el mensaje por terminado y empezara a determinar cual de las posibilidades es el mensaje original en base a un diccionario basico con palabras tipicas para poder hacer que el codigo reconozca que palabras son palabras reales y no rubish, en base al mensaje con mas palabras coerentes sera normalmente considerado el mensaje original.

- Flujo de uso de los programas: Se tiene pensado que el uso de los codigos siga un orden determinado para su correcto funcionamiento, este seria: primero usar el Cesar_translate.py para crear el mensaje_cifrado.txt con el mensaje que se usara para enviar, luego se prepararan en terminales distintas los codigos Cesar_sender.py y Cesar_descifrator.py, en este caso se ejecutara Cesar_descifrator.py para que este listo escuchando por mensajes icmp requests que salgan del computador y luego se ejecutara Cesar_sender.py para mandar los paquetes que seran captados por Cesar_descifrator.py quien estaba a la espera de estos.

- Ejemplo de Alejandro: Se preparo un mensaje primero con Cesar_translate.py ejecutandolo con visual studio code y luego se preparo una terminal cmd en la carpeta direccion de Cesar_descifrator.py para ejecutarlo, al mismo tiempo se ejecuto Cesar_sender.py en la terminal del visual studio code para cumplir con el flujo de uso pensado.
